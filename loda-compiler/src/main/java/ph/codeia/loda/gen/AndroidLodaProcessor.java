/*
 * Copyright (c) 2016 by Mon Zafra.
 */

package ph.codeia.loda.gen;

import com.google.auto.common.AnnotationMirrors;
import com.google.auto.common.MoreElements;
import com.google.auto.service.AutoService;
import com.squareup.javapoet.AnnotationSpec;
import com.squareup.javapoet.CodeBlock;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;

import java.io.File;
import java.io.IOException;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.Messager;
import javax.annotation.processing.ProcessingEnvironment;
import javax.annotation.processing.Processor;
import javax.annotation.processing.RoundEnvironment;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.AnnotationMirror;
import javax.lang.model.element.Element;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.NestingKind;
import javax.lang.model.element.TypeElement;
import javax.lang.model.util.Elements;
import javax.tools.Diagnostic;

import ph.codeia.loda.Loda;

/**
 * This file is a part of the Loda project.
 */

@AutoService(Processor.class)
public class AndroidLodaProcessor extends AbstractProcessor {

    static final String SIGNATURE =
            "Generated by Loda\nhttps://github.com/monzee/Loda.git\n";

    private final File destination;

    public AndroidLodaProcessor() {
        destination = null;
    }

    public AndroidLodaProcessor(String filename) {
        destination = new File(filename);
    }

    private Messager msg;

    @Override
    public synchronized void init(ProcessingEnvironment processingEnv) {
        super.init(processingEnv);
        msg = processingEnv.getMessager();
    }

    @Override
    public SourceVersion getSupportedSourceVersion() {
        return SourceVersion.latestSupported();
    }

    @Override
    public Set<String> getSupportedAnnotationTypes() {
        Set<String> names = new HashSet<>();
        for (Class<?> c : new Class<?>[] {
                Loda.Lazy.class,
                Loda.Async.class,
                Loda.Got.class,
        }) {
            names.add(c.getCanonicalName());
        }
        return names;
    }

    @Override
    @SuppressWarnings("OptionalGetWithoutIsPresent")
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        try {
            Elements elements = processingEnv.getElementUtils();
            Checker targets = new Checker(processingEnv.getTypeUtils());
            for (Element elem : roundEnv.getElementsAnnotatedWith(Loda.Lazy.class)) try {
                targets.addLazyNode(
                        valueOf(MoreElements.getAnnotationMirror(elem, Loda.Lazy.class).get()),
                        elem
                );
            } catch (Gen.DuplicateId | Gen.TypeMismatch e) {
                err(e.getMessage(), e.element);
                return true;
            }
            for (Element elem : roundEnv.getElementsAnnotatedWith(Loda.Async.class)) try {
                targets.addAsyncNode(
                        valueOf(MoreElements.getAnnotationMirror(elem, Loda.Async.class).get()),
                        elem
                );
            } catch (Gen.DuplicateId | Gen.TypeMismatch e) {
                err(e.getMessage(), e.element);
                return true;
            }
            for (Element elem : roundEnv.getElementsAnnotatedWith(Loda.Got.class)) try {
                targets.addGotNode(
                        valueOf(MoreElements.getAnnotationMirror(elem, Loda.Got.class).get()),
                        elem
                );
            } catch (Gen.DuplicateId | Gen.TypeMismatch e) {
                err(e.getMessage(), e.element);
                return true;
            }
            Map<TypeElement, Gen.Model> hostModels = targets.dump();
            for (TypeElement host : hostModels.keySet()) try {
                Gen.Model model = hostModels.get(host);
                TypeName hostType = TypeName.get(host.asType());
                TypeSpec.Builder loda = TypeSpec
                        .classBuilder(nameAfter(host))
                        .addModifiers(Modifier.PUBLIC)
                        .addAnnotation(AnnotationSpec.builder(Loda.Backlink.class)
                                .addMember("value", CodeBlock.of("$T.class", hostType))
                                .build())
                        .addJavadoc(SIGNATURE)
                        .addField(hostType, "host", Modifier.FINAL)
                        .addMethod(MethodSpec.constructorBuilder()
                                .addModifiers(Modifier.PUBLIC)
                                .addParameter(hostType, "host")
                                .addStatement("this.host = host")
                                .build());
                JavaFile file = JavaFile.builder(
                        elements.getPackageOf(host).toString(),
                        new AndroidGenerator(model).generate(loda)
                ).build();
                if (destination == null) {
                    file.writeTo(processingEnv.getFiler());
                } else {
                    file.writeTo(destination);
                }
            } catch (IOException e) {
                err(e.getMessage(), host);
            }
        } catch (RuntimeException e) {
            err("[runtime] unexpected things happen. good luck!");
            throw e;
        }
        return true;
    }

    private static String nameAfter(TypeElement host) {
        StringBuilder parts = new StringBuilder("_Loda");
        while (host.getNestingKind() != NestingKind.TOP_LEVEL) {
            parts.insert(0, '$');
            parts.insert(1, host.getSimpleName().toString());
            host = MoreElements.asType(host.getEnclosingElement());
        }
        parts.insert(0, host.getSimpleName().toString());
        return parts.toString();
    }

    private static int valueOf(AnnotationMirror annotation) {
        return (int) AnnotationMirrors.getAnnotationValue(annotation, "value").getValue();
    }

    private void err(String message) {
        msg.printMessage(Diagnostic.Kind.ERROR, message);
    }

    private void err(String message, Element elem) {
        msg.printMessage(Diagnostic.Kind.ERROR, message, elem);
    }

}

